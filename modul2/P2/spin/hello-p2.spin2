con
  _clkfreq = 160_000_000

  RX1     = 35  { I }                                           ' programming / debug
  TX1     = 37  { O }
  BR_TERM  = 115_200                                            ' terminal baud rate

  ADC_CLK = 16
  ADC_SDO = 17
  ADC_SDI = 18
  ADC_DRDY = 19
  ADC_CS = 20
  ADC_PDWN = 21

  TRIGGER = 22
  INSTRUCTION_BUFFER_SIZE = 2
  BUFFER_SIZE = 100
var
  BYTE instruction_buffer[INSTRUCTION_BUFFER_SIZE]
  LONG read
  LONG write
  LONG buffer[BUFFER_SIZE * 2]
obj
  term : "jm_fullduplexserial"
  adc : "buffered_ads1256"

pub main | a, b, c, channel, timestamp, mux, value, rpos, wpos
  term.start(RX1, TX1, %0000, BR_TERM)
  read := BUFFER_SIZE
  adc.start(ADC_SDI, ADC_SDO, ADC_CLK, ADC_CS, ADC_DRDY, ADC_PDWN, @read)

  pinlow(TRIGGER)
  pinhigh(TRIGGER)
  adc.wreg(adc.DRATE, %00000011) ' 2.5SPS
  a := adc.rreg(adc.DRATE, 1)
  'term.fstr1(string("ADC DRATE \%%8.8b\r\n"), a) ', b, c)

  instruction_buffer[0] := (0 << 4) | (1 << 3) ' AIN-channel and AINCOM
  instruction_buffer[1] := (1 << 4) | (1 << 3) ' AIN-channel and AINCOM
  adc.start_continuous_read(@instruction_buffer, INSTRUCTION_BUFFER_SIZE)
  repeat
    timestamp, mux, value := adc.read_continuous
    term.fstr3(string("ICDAC %8.8x MUX 0x%2.2x: %8.8x\r\n"), timestamp, mux, value)
    'term.fstr2(string("\r\nrpos: %d wpos: %d\r\n\r\n"), rpos, wpos)
    term.fstr3(string("MUX0 0x%2.2x MUX1 0x%2.2x, %d\r\n"), instruction_buffer[0], instruction_buffer[1], adc.available)