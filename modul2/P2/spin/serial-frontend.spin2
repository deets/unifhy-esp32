con
  _clkfreq = 160_000_000

  ' A propplug on a header
  RX0     = 35
  TX0     = 37
  BR_SERIAL = 115200

  DEBUG_BAUD  = 230_400
  DEBUG_COGS = %11111110

  ADC_CLK = 16
  ADC_SDO = 17
  ADC_SDI = 18
  ADC_DRDY = 19
  ADC_CS = 20
  ADC_PDWN = 21

  LF = $a
  CR = $d
  DOLLAR = $24
  ASTERISK = $2a

  INSTRUCTION_BUFFER_SIZE = 8
  BUFFER_SIZE = 100
  SERIAL_BUFFER_SIZE = 1024

  SD_DO = 58
  SD_DI = 59
  SD_CS = 60
  SD_CLK = 61

var
  BYTE instruction_buffer[INSTRUCTION_BUFFER_SIZE]
  LONG read
  LONG write
  LONG buffer[BUFFER_SIZE * 2]
  BYTE serial_input_buffer[6]  ' We always start with $RQADS
  BYTE payload[SERIAL_BUFFER_SIZE - 6]
  BYTE serial_input_buffer_pos
  BYTE serial_output_preamble[6] ' Again $RQADS
  BYTE serial_output_buffer[SERIAL_BUFFER_SIZE]
  WORD serial_output_buffer_pos
  BYTE thinning
  BYTE mux_buffer[8]
  BYTE mux_buffer_length

obj
  adc: "buffered_ads1256"
  serial: "jm_fullduplexserial"
  sdwriter: "sdwriter"
  util: "util"

pub main() | c, correct, success
  bytemove(@serial_output_preamble, string("$RQADS"), 6)

  serial_output_buffer_pos := 0
  thinning := 255
  serial.start(RX0, TX0, %0000, BR_SERIAL)
  read := BUFFER_SIZE
  adc.start(ADC_SDI, ADC_SDO, ADC_CLK, ADC_CS, ADC_DRDY, ADC_PDWN, @read)
  sdwriter.start()
  serial_input_buffer_pos := 0

  repeat
    if serial.available() > 0
      repeat serial.available()
        c := serial.rx()
        serial_input_buffer[serial_input_buffer_pos] := c
        serial_input_buffer_pos := (serial_input_buffer_pos + 1) +// SERIAL_BUFFER_SIZE
        serial_input_buffer[serial_input_buffer_pos] := 0 ' terminate

        if c == LF
          if rq_datagram()
            correct := rq_process()
            ifnot correct
              debug(zstr(string("incorrect command")))
            ' Send any lingering data
            rq_finalize(serial_output_buffer_pos)

          reset_buffer()

pri reset_buffer()
  serial_input_buffer_pos := 0

pri rq_datagram() : result | p, wire_checksum, local_checksum
  {{
  A correct datagram looks like this:

  $RQADS<instructions>*CS\r\n

  where CS is a 1-byte checksum built by XOR'ing together
  all characters between $ and *, and then represented
  as hexadecimal character.

  None of the bytes in <instructions> is allowed to be \r or \n
  }}
  result := false
  if serial_input_buffer_pos >= 11 ' $RQADS*AB\r\n is 11 characters long
    p := serial_input_buffer_pos
    if serial_input_buffer[0] == DOLLAR and serial_input_buffer[p - 1] == LF and serial_input_buffer[p - 2] == CR and serial_input_buffer[p - 5] == ASTERISK
      wire_checksum := util.decode_hex_byte(@serial_input_buffer[p - 4])
      local_checksum := util.compute_checksum(@serial_input_buffer[1], @serial_input_buffer[p - 6])
      result := wire_checksum == local_checksum
  return result

pri rq_process() : result | payload_length
  payload_length := serial_input_buffer_pos - 6 - 5 ' remove $RQADS and *XX\r\n
  case payload[0]
    "P" : result := rq_ping(payload_length)
    "R" : result := rq_rate(payload_length)
    "T" : result := rq_thinning(payload_length)
    "C" : result := rq_cdac(payload_length)

pri rq_cdac(payload_length) : result | payload_offset, buffer_offset
  ' A cdac command looks like
  ' C<N>:XY{N}
  ' where N is the number of mux-instructions
  ' that must be in 1..8 and then N mux-instructions
  debug(zstr(string("rq_cdac")))
  if payload_length < 5 ' RN:XY
    debug(zstr(string("cdac minimal length violation")))
    return FALSE
  payload_offset := 1
  buffer_offset := 0
  mux_buffer_length := util.decode_nibble(payload[payload_offset])
  if mux_buffer_length < 0 and mux_buffer_length > 8
    debug(zstr(string("cdac mux length violation")))
    return FALSE
  debug(zstr(string("cdac mux")))
  debug(udec(mux_buffer_length))
  payload_offset += 1 ' skip N
  ' we must have :XY worth mux_buffer_length
  if payload_offset + 3 * mux_buffer_length > payload_length
    debug(zstr(string("cdac payload length violation")))
    debug(udec(payload_length))
    debug(udec(payload_offset + (3 * mux_buffer_length)))
    return FALSE
  debug(zstr(string("mux")))
  debug(udec(mux_buffer_length))

  repeat buffer_offset from 0 to mux_buffer_length - 1
    payload_offset += 1 ' skip :
    mux_buffer[buffer_offset] := util.decode_hex_byte(@payload + payload_offset)
    payload_offset += 2 ' skip XY
    debug(zstr(string("mux")))
    debug(udec(buffer_offset))
    debug(uhex_byte(mux_buffer[buffer_offset]))

  do_cdac()
  return TRUE

pri do_cdac() | mux, timestamp, value, thinning_count
  sdwriter.begin()
  adc.start_continuous_read(@mux_buffer, mux_buffer_length)
  thinning_count := 0
  serial_output_buffer_pos := 0

  repeat
    ' we always want to send all mux values,
    ' thinning applies to full sets of values
    repeat mux_buffer_length
      ' any data on serial stops cdac
      repeat until adc.available() > 0
        if serial.available() > 0
          adc.stop_continuous_read()
          ' TODO: consume the rest of the buffer before
          ' closing down
          sdwriter.end()
          return
      timestamp, mux, value := adc.read_continuous()
      sdwriter.feed(timestamp, mux, value)
      if thinning == 0 or thinning_count == 0
        thinning_count := thinning
        ' debug(zstr(string("----")))
        ' debug(uhex(timestamp))
        ' debug(uhex_byte(mux))
        ' debug(uhex_long(value))

        rq_send_str(string("C"))
        rq_send_hex_long(timestamp)
        rq_send_hex_byte(mux)
        rq_send_hex_long(value)
        rq_finalize(serial_output_buffer_pos)

      thinning_count -= 1

pri rq_rate(payload_length) : result | rate
  debug(zstr(string("rq_rate")))
  if payload_length <> 4 ' R:XY
    return FALSE
  if payload[1] <> ":"
    return FALSE
  rate := util.decode_hex_byte(@payload + 2) ' read the hex number directly after R:
  adc.wreg(adc.RDRATE, rate)
  debug(uhex_byte(rate))
  rq_send_str(string("R"))
  return TRUE

pri rq_thinning(payload_length) : result | rate
  debug(zstr(string("rq_thinning")))
  if payload_length <> 4 ' T:XY
    return FALSE
  if payload[1] <> ":"
    return FALSE
  thinning := util.decode_hex_byte(@payload + 2) ' read the hex number directly after R:
  debug(uhex_byte(thinning))
  rq_send_str(string("T"))
  return TRUE

pri rq_ping(payload_length) : result
  debug(zstr(string("rq_ping")))
  if payload_length <> 1
    return FALSE
  rq_send_str(string("P"))
  return TRUE

pri rq_finalize(length) | checksum, i
  if serial_output_buffer_pos == 0
    return

  checksum := 0
  repeat i from 1 to length + 5 ' the RQADS is included in the checksum!
    checksum ^= serial_output_preamble[i]
  serial_output_buffer[length] := ASTERISK
  serial_output_buffer[length + 1] := util.encode_nibble(checksum >> 4)
  serial_output_buffer[length + 2] := util.encode_nibble(checksum & $f)
  serial_output_buffer[length + 3] := 13 ' \r
  serial_output_buffer[length + 4] := 10 ' \n
  serial.substr(@serial_output_preamble, 6 + 5 + serial_output_buffer_pos)
  serial_output_buffer_pos := 0

pri rq_send_str(str_addr) | l
  l := strsize(str_addr)
  if serial_input_buffer_pos + l + 5 > SERIAL_BUFFER_SIZE
    debug(zstr(string("serial output buffer overflow")))
  bytemove(@serial_output_buffer + serial_output_buffer_pos, str_addr, l)
  serial_output_buffer_pos += l

pri rq_send_hex_long(value) | shift, h
  rq_send_str(string(":"))
  serial_output_buffer_pos += util.encode_hex_long(@serial_output_buffer + serial_output_buffer_pos, value)

pri rq_send_hex_byte(value) | shift, h
  rq_send_str(string(":"))
  serial_output_buffer_pos += util.encode_hex_byte(@serial_output_buffer + serial_output_buffer_pos, value)
